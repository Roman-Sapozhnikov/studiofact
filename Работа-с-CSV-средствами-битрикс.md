    require_once ($_SERVER["DOCUMENT_ROOT"]."/bitrix/modules/main/classes/general/csv_data.php");
    $csvFile = new CCSVData('R', true);
    $csvFile->LoadFile($_FILES['csv']['tmp_name']);
    $csvFile->SetDelimiter(',');
    while ($arRes = $csvFile->Fetch()) {
       echo($arRes);
    }

Собственно: 
- подключаем файл класса работы с CSV 
- создаем объект класса, указываем, что будет использоваться разделитель (R, есть еще фикс.поля F), и первая строка содержит заголовки (true); можно не указывать эти параметры и задать отдельными методами
    
`$csvFile->SetFieldsType($fields_type);`

`$csvFile->SetFirstHeader();`

- загружаем файл
- ставим делиметер, где допустимые параметры: \t (табуляция), запятая, пробел, точка с запятой. 
- бежим как при обычной выборке из базы.


### Статья по генерации CSV-файла:
В этой статье я хочу предложить вашему вниманию описание работы с CSV-файлами в Битрикс. 
Надеюсь, все в курсе того, что есть такая замечательная вещь, как импорт/экспорт инфоблоков, а также торгового каталога (в соответствующих редакциях) в CSV и XML-файлы.

Но что делать в случае, если в CSV-файл необходимо внести товары только одного раздела, сохраняя структуру его подразделов и принадлежность товаров к ним? Что делать в случае, если в CSV-файл необходимо экспортировать все свойства какого-то инфоблока, с учетом их типов, символьных кодов и т.п.?

Что делать, если нужен такой CSV-файл, который не получишь нажатием одной кнопочки в админке?
Для этого в Битрикс есть класс CCSVData.

**1. Подключаем.**

Чтобы использовать его в своем скрипте, вначале его подключаем:

    require_once($_SERVER["DOCUMENT_ROOT"]."/bitrix/modules/main/classes/general/csv_data.php");

**2. Создаем объект, задаем тип полей и разделители**

Затем создаем новый объект класса:

    $csvFile = new CCSVData();
    $fields_type = 'R';
    $delimiter = ";";
    $csvFile->SetFieldsType($fields_type);
    $csvFile->SetDelimiter($delimiter);

**3. Визуализируем задачу (по необходимости)**

Я не знаю, как остальные, но я - человек, который лучше воспринимает информацию зрительно. Поэтому всегда либо ручкой на листочке, либо в какой-то программе – сначала  я проектирую то, как должен выглядеть результат. Мой результат в данной задаче – это CSV-файл с нужными столбцами в нужном порядке. Я открываю Excel и делаю такой файл, вернее, его «шапку» - пишу все столбцы, которые мне нужны – чтобы ничего не забыть.
Если уверены, что можете все держать в голове, и ничего не забыли, то пропускайте этот шаг.

На основе тех столбцов, которые нам нужны, собираем  шапку – это обычный массив, каждое значение которого – это название столбца.

    $arrHeaderCSV = array("NAME","CODE","SORT","GROUP1","GROUP2","PREVIEW_TEXT", "DETAIL_TEXT","SMALL_IMG","BIG_IMG","PRICE", "CURRENCY", "CATALOG_QUANTITY","CATALOG_QUANTITY_TRACE", "ARTICUL","NEW","MOREPHOTO","ACTIVE", "EX_ID","CODG_1", "CODG_2", "G_ACT1", "G_ACT2","G_SORT1","G_SORT2","XML_ID", "S_TYPE","B_TYPE");

Взято из рабочего примера, поэтому полей тут немало.  Использовалось для разнесения каталога продукции по разным инфоблокам – с сохранением структуры подразделов в разделе. (Каждый раздел верхнего уровня из старого каталога продукции стал отдельным инфоблоком, его подразделы – разделами верхнего уровня и т.д. , с сохранением индексов сортировки, активности и т.п.)

Сделали «шапку» - сохраняем:

    $csvFile->SaveFile("astra.csv", $arrHeaderCSV);

Метод  SaveFile дописывает в файл, имя которого указано в 1 параметре, строчку с данными, которые содержатся в массиве $arrHeaderCSV.

Открываем astra.csv, который сгенерировался , в Excel – все ОК, получилось тоже самое, что я сначала проектировала «руками».

**4. Генерируем CSV.**

Дальше запускаем скрипт, который собирает данные и дописывает их в файл.

В моем скрипте это был цикл,  в теле которого на каждом шаге собирался опять же массив, аналогичный массиву с «шапкой», только со значениями соответствующих полей, а не их названиями  и вызывался метод SaveFile. Скрипт большой, т.к. он еще и «дергал» фото +доп.фото товаров, а также сохранял старые ID товаров, чтобы потом перенести торговые предложения. Выкладывать сюда такой объем кода не вижу никакого смысла – вас это только запутает.

В принципе, все. Как видите, все очень просто.

**5. Итоги**

Подведем итог. Чтобы сгенерировать CSV-файл, (который только душенька пожелает), нужно:

- подключить класс для работы с CSV
- задать тип полей и разделители
- собрать "шапку" для CSV-файла (если таковая вообще вам нужна)
- при помощи метода SaveFile сгенерировать файл на основе массива данных (каждая строчка – это массив).